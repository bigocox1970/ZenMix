-- Create audio_tracks table
CREATE TABLE IF NOT EXISTS audio_tracks (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  category TEXT NOT NULL,
  url TEXT NOT NULL,
  file_path TEXT,
  duration INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add RLS policies
ALTER TABLE audio_tracks ENABLE ROW LEVEL SECURITY;

-- Policy for users to view only their own tracks
CREATE POLICY "Users can view their own tracks" 
  ON audio_tracks 
  FOR SELECT 
  USING (auth.uid() = user_id);

-- Policy for users to insert their own tracks
CREATE POLICY "Users can insert their own tracks" 
  ON audio_tracks 
  FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

-- Policy for users to update their own tracks
CREATE POLICY "Users can update their own tracks" 
  ON audio_tracks 
  FOR UPDATE 
  USING (auth.uid() = user_id);

-- Policy for users to delete their own tracks
CREATE POLICY "Users can delete their own tracks" 
  ON audio_tracks 
  FOR DELETE 
  USING (auth.uid() = user_id);

-- Create storage bucket for audio files
INSERT INTO storage.buckets (id, name, public) 
VALUES ('audio-files', 'audio-files', true)
ON CONFLICT (id) DO NOTHING;

-- Set up storage policies
CREATE POLICY "Public can read audio files"
  ON storage.objects
  FOR SELECT
  USING (bucket_id = 'audio-files');

CREATE POLICY "Authenticated users can upload audio files"
  ON storage.objects
  FOR INSERT
  WITH CHECK (
    bucket_id = 'audio-files' AND
    auth.role() = 'authenticated' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY "Users can update their own audio files"
  ON storage.objects
  FOR UPDATE
  USING (
    bucket_id = 'audio-files' AND
    auth.role() = 'authenticated' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY "Users can delete their own audio files"
  ON storage.objects
  FOR DELETE
  USING (
    bucket_id = 'audio-files' AND
    auth.role() = 'authenticated' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );
